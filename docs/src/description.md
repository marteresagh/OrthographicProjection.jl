# Description
In this package you can find two main algorithms:
 - *segment* : allows you to clip the points of a 3D point cloud contained in a volume,
 - *orthophoto* : generates the image as orthographic projection of 3D point cloud (whole or clipped in a volume) with respect to a chosen plane

Both of them has the same **core function**, that takes as input a [point cloud Potree project](https://github.com/potree/potree) and a [cuboidal LAR model](https://github.com/cvdlab/LinearAlgebraicRepresentation.jl).

## Input Point Cloud
To manage a point cloud with huge number of points we use Potree project, achieved with the tool [PotreeConverter 1.7](https://github.com/potree/PotreeConverter/tree/master).

### Potree
A Potree is a data structure, used to store huge point clouds, based on octree. All details of this structure are described by Markus SchÃ¼tz in his [thesis](https://www.cg.tuwien.ac.at/research/publications/2016/SCHUETZ-2016-POT/SCHUETZ-2016-POT-thesis.pdf).

![potree](./images/Octree.jpg)

A Potree project is a collection of files, for each node of the octree there is a file called r, followed by a numeric code indicating its position in the hierarchy, for example:
 - **r** is the root node,
 - **r0** is the first child of the root node,
 - **r07** is the eighth child of the first child of the root node.

Due to particular way of tagging nodes, it is possible store Potree in a trie data structure, provided by Julia in module `DataStructures.jl`. As the usual tree data structure, a trie is made up of collections of trie node. Every trie node has three components:
- a value, where store information: in our case the path to the (LAS or LAZ) file associated;
- a map, where key is a digit and the value is trie node, used to establish the parent-child relationship;
- boolean value, indicating the end of word. In our case `true` in each node.

## Core Function: Trie Traversal
To speed up the search for points falling within the region of interest we use trie to process the whole point cloud.
Each node of Potree is generated by the decomposition of space into congruent regions: the volume occupied by the octree node is described as an **AABB**, which we find in the header of the file associated with the node.
Assuming this, we only process nodes that intersect the volume.
There are three possible options of intersection, see figure below:
 - `0` -> volume not intersect octree node (skip this node and all subtree)
 - `1` -> volume intersect, but not contains, octree node (check for this node and his children)
 - `2` -> volume contains octree node (process this node and all subtree)

![example](./images/DFS.png)

In figure:
pink volume represents region of interest, points in yellow quads (`0`) are not processed, in green quads (`1`) only the points falling in pink volume are processed, and, without further checks, all points in blue quads (`2`) are processed.


#### Pseudocode
```julia

function trie_traversal(trie::Trie, volume::Model):
  AABB = boundingbox(trie)

	intersection = modelsdetection(volume, AABB)
  if intersection == 2
    for k in keys(trie)
      file = trie[k]
      process(file)
    end
  elseif intersection == 1
    dfs(trie, volume)
  end
end

function dfs(trie::Trie, volume::Model):

	file = trie.value
	octree = octree2aabb(file)
	intersection = modelsdetection(volume, octree)

	if intersection == 1
		processif(file)

		for key in collect(keys(trie.children))
			dfs(trie.children[key], volume)
		end

	elseif intersection == 2

		for k in keys(trie)
			file = trie[k]
			process(file)
		end

	end
end
```

## Process: segment and orthophoto

#### Segment
All points of input point clouds within region of interest are simply stored and saved in a new LAS file.

#### Orthophoto
Orthographic view projects at a right angle to the data plane.

An image is just a multidimensional array: a grid (with 3 channel for storing RGB color attribute) is inscribed into the projection of volume.

The first point that falls into a cell will be accepted and its quote (distance to plane) is stored in a buffer. If a point falls inside a cell that is already occupied then the point with the highest quote is accepted, because it is the closest point to the observer.
![orthographic projection](./images/raster.png)
